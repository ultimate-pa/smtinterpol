Proofs for SAT
==============

Normally a model is already a proof that a formula is satisfiable: Using a model, the asserted input formulas can be
quickly evaluated to check that they all evaluate to true.  However, this is no longer trivial, if the input contains
quantifiers.

Method 1: Models
----------------

If the model also gives a value for the `choose` operator for each quantified formulas, we can still quickly evaluate
the formula.  For example, `exists x. p(x)` can be evaluated as `p(choose x. p(x))`.  The latter can be evaluated by 
replacing the outermost `p` and the `choose` operator by the definition given in the model. However if that evaluates to
`false`, it would not be a proof that the choice given by the model is valid. One way to ensure that the model chose a
right value, is add a proof for `exists x. p(x) => p(|choose x. p(x)|)`, where `|choose x. p(x)|` is the definition given by
the model.


Example 1: Lets assume the model defines

```
(define-fun p (x Int) Bool (ite (< x 0) true false))
(define-fun |choose x.p(x)| Int (- 3))
```

In this case proving the required formula `exists x. p(x) => p(|choose x. p(x)|)` is very easy, as the right-hand-side
evaluates to `true`.

Example 2: Lets assume the input formula contains `exists x. (< (* x x) 0)`.  In this case the `exists` evaluates to
false and the model can define the choose function arbitrarily, e.g.

```
(define-fun |choose x. (< (* x x) 0)| Int 0)
```

The tricky part is to prove the correctness of the witness.  We need the axioms of arithmetic to prove that for an
arbitrary `x`, the formula `(< (* x x) 0)` is always `false`.

Method 2: Proof of Assert
-------------------------

We could also provide a resolution proof for each of the input formula using the definition provided by the model.
The proof should start with a `define-fun` application for each declared function and possibly for the built-in
functions like `div` or data type selectors that are only partially defined.  For partial builtin functions it should
be syntactically clear that it does not change the meaning for inputs where the function is defined.  In particular the
definition for `div x y` should be `(ite (= y 0) ... (div x y))` and the definition for the `car x` should be 
`(ite ((_ is cons) x) (car x) ...)`.

The proof itself can use the `expand` axiom to add the unit clause `{ (= (f x) ..definition of f x..)  }`.  There should be
one proof object for every input assertion.


Strategy in SMTInterpol
-----------------------

We plan to implement Method 2.  One reason is that it is not clear how to generate the proofs for the false `exists`
quantifiers and the true `forall` quantifiers from the proofs generated by MBQI or the full instantiation for formulas
in the sat fragment.  Another is that we would need to figure out how to associate the the Skolem functions with the
`choose` operators in the original formula, especially, if the preprocessing is extended.

One prerequisite for Method 2 is that the proof tracking must also track the part needed for SAT proofs.  The 
TermCompiler phase is unproblematic, as we already show equivalence.  But for the clausifier we need to show that the
input formula holds if all clauses hold.  In particular the splitting for `and` must also track the `and` introduction
rule. We also need a slightly different handling of named atoms/anonymous CC terms: while for unsat proof we just use
the term for which they stand, for sat proofs we need to show the original formula under the assumption that the named
atom/anonymous CC term stands for the term it should stand for.

One advantage is that we can also proof that the preprocessing is correct for SAT and that we not accidentally found a
valid model that also satisfies the input formula.  We could even check the correctness of the pre-processing without
producing a model.

Challenges
----------

1. How to prove Named Atoms / Plaisted–Greenbaum Encoding
2. Can/should we prove the missing excluded middle axioms similarly?
3. Similar questions for AUX functions.
4. div/mod encoding
5. arrays and finite element types/finite index types.
6. model for uninterpreted sorts (should we give a concrete data type model?)

ad 1.
We probably need to introduce an uninterpreted Boolean variable for each NamedAtom, e.g., for a
Named Atom `(and a b c)` we introduce a boolean `|(and a b c)|`.   For the clauses we generate directly from `F` we show
that `(=> (and a b c) |(and a b c)|)` and the clauses imply `F`.  For the Plaisted–Greenbaum clauses for `|(and a b c)|` we
show that they imply `(=> (and a b c) |(and a b c)|)`.

ad 3.
We need to show that `(forall ... (=> (boolean formula with free variable) (= (@AUX X Y Z) true))`  (or vice versa) follows
from the generated AUX axioms and that this formula implies that the clauses generated from a formula F imply F.

Since we generate models for the aux variables/named atoms, we may also check that these models satisfy the
implications, at least if there is no quantified formula involved below.

ad 4.
Similarly, we add an uninterpreted integer `|(div x 5)|` for `(div x 5)` and show that the axioms we generate for this
imply `(= |(div x 5)| (div x 5))`.  Then we show that under this assumption the clauses we generate for an input formula
`F` imply `F`.

ad 2.
We can introduce an uninterpreted sort `CCBool` and uninterpreted constants `CCtrue`, `CCfalse` and a new uninterpreted
constant for every boolean CC term.  Then show that `(= term (= CCterm CCtrue))` and maybe also 
`(= (not term) (= CCterm CCfalse))` follow from all the excluded middle axioms.

ad 5.
Here we have several hurdles:  For finite element types we add `(select a i)` to the CC graph to force the CC solver
to find a value for it, while for infinite element types, we can just ignore finding a value for it, as we will later
always be able to pick a fresh value.  This seems more a model generation issue, as we would find the problem, if we
try to pick a fresh value for the `select` but the domain doesn't support it.  Also just instantiating the node in the
CC graph does not necessarily add any axioms immediately, e.g., for finite data types.  So I don't think that the 
preprocessing proofs should check that the creation of CC nodes happen.

The other is the `const` proof rule, which the ProofSimplifier still does not support.  It is only sound for infinite
data types and we basically need to show that there is an index that is different to all indices in the store chain. 
For arithmetic we could use the maximum of all the indices plus one and show that for this index we get a contradiction.


Supported Quantifier Fragment
-----------------------------
If a formula is in the almost uninterpreted fragment, we basically know that the quantifiers are true if they are true
for every interesting term.  So we need to proof that the formula holds for the real `choose` term corresponding to that
quantifier.

Evaluation as Proof
-------------------

We could also just use the define-fun+proof format and evaluate the formula to prove that it holds.  It's basically a
rewrite proof plus poly+/poly* to care for arithmetic operations.  In some cases we can also use short-cut evaluation,
e.g., if the asserted formula is `(or p1 p2 p3)` and `p2` evaluates to `true`, we only need to include the evaluation
proof for `(= p2 true)` derive from it `p2` and use that to prove `(or p1 p2 p3)`.  The formulas `p1`, `p3` do not need to
be evaluated at all.


SAT Proofs for Formula Splitting
--------------------------------

For every input formula remember the proof of the input formula.  When there are pending `AddAsAxiom(F_i)` on the todo stack, build a proof for the clause `{~F_1, ..., ~F_n, input}`.   When `buildClause(F_i)` is called, the proof will leave `~F_i` in the proved clause.

For every `BuildClause(F)` object and every literal `lit_i` in the clause that is built in the end, there is a build-clause proof that will prove `{~lit_i, F}`.   If the clause is quantified, the proof will prove the clause
`{~lit_i(choose (x) (not (F x)), (forall (x) F)}`

For every named atom `lit`, we remember a proof for  `{~F_1,...,~F_n, lit}`, where `F_i` are the axiom parameters of the `buildAuxClause` calls.

Take the proof of the input clause, then iterate all clauses built for these input.
For each of these clause, find a literal that is true, and take the proof for that literal and resolve it with the proof.
If the literal is a named literal, take the proof for that literal `{~F_1,...,~F_n,lit}` and resolve with that.
Again find the clauses built for the literals and find a true literal in each of them.
We end up with a proof of `{~lit_1, ..., ~lit_n, input}`, where `lit_i` are all true basic literals.  These can be proved by looking at the current model.


For a quantified formula, we first need to proof the quantified clause, i.e., we need a proof for
`{lit_1(choose x F), ..., lit_n(choose x F)}`, where F is the formula that correspond to the quantified clause.
This is the clause that model-based quantifier instantiation would prove.
Then resolve this with the literals `{~lit_i(choose x F), forall F}` to obtain a proof for `forall F`. 


Instead of `{~lit(choose x F), (forall x F)}`  we could build proofs for
`{~lit(choose x F), F_i(choose x input)}`  where F_i is the formula (with free variables) from which the quantified clause is built.


Example
-------

The formula `(forall ((x Int) (y Int)) (=> (<= x y) (<= (f x) (f y))))` and `(= (f 0) 0)` and `(= (f 100) 1)` is satisfiable.
One model would be `(define-fun f ((@p0 Int)) (ite (<= @p0 0) 0 1))`

proof idea:

```
to prove: (=> (<= skox skoy) (<= (f skox) (f skoy))
assume (<= skox skoy)
assume ~(<= (f skox) (f skoy))
case 1: (<= skox 0)
   then by (expand (f skox)) and ite1: (= (f skox) 0)
   by expand (f skoy) and ite1 and ite2: (= (f skoy) 0) or (= (f skoy) 1)
   in both cases contradicts ~(<= (f skox) (f skoy))
case2: ~(<= skox 0)
   then also ~(<= skoy 0) because of (<= skox skoy).
   by expand (f skox) and ite2: (= (f skox) 1)
   by expand (f skoy) and ite2: (= (f skoy) 1)
   contradicts ~(<= (f skox) (f skoy))
```


manual proof:

```
sat
((refine-fun f ((z Int)) (ite (<= z 0) 0 1))
 (let ((quant (forall ((x Int) (y Int)) (=> (<= x y) (<= (f x) (f y)))))) 
 (let ((skox (choose (x Int) (not (forall ((y Int)) (=> (<= x y) (<= (f x) (f y))))))))
 (let ((skoy (choose (y Int) (not (=> (<= skox y) (<= (f skox) (f y)))))))
 (let ((qbody (=> (<= skox skoy) (<= (f skox) (f skoy)))))
 (let-proof ((prfqbody (res (<= skox skoy) (=>+ 0 qbody) (res (<= (f skox) (f skoy)) (let ((itex (ite (<= skox 0) 0 1)) (itey (ite (<= skoy 0) 0 1))) (res (= (f skox) itex) (expand (f skox)) (res (= (f skoy) itey) (expand (f skoy)) (res (< (f skoy) (f skox)) (total (f skox) (f skoy)) (res (<= skox 0) (res (= (f skox) 1) (res (= itex 1) (ite2 itex) (trans (f skox) itex 1)) (res (<= skoy 0) (res (= (f skoy) 1) (res (= itey 1) (ite2 itey) (trans (f skoy) itey 1)) (res (= 1 (f skoy)) (symm 1 (f skoy)) (farkas 1 (< (f skoy) (f skox)) 1 (= (f skox) 1) 1 (= 1 (f skoy))))) (res (< 0 skox) (total skox 0) (farkas 1 (<= skox skoy) 1 (<= skoy 0) 1 (< 0 skox))))) (res (= (f skox) 0) (res (= itex 0) (ite1 itex) (trans (f skox) itex 0)) (res (<= skoy 0) (res (= (f skoy) 1) (res (= itey 1) (ite2 itey) (trans (f skoy) itey 1)) (res (= 1 (f skoy)) (symm 1 (f skoy)) (farkas 1 (< (f skoy) (f skox)) 1 (= (f skox) 0) 1 (= 1 (f skoy))))) (res (= (f skoy) 0) (res (= itey 0) (ite1 itey) (trans (f skoy) itey 0)) (res (= 0 (f skoy)) (symm 0 (f skoy)) (farkas 1 (< (f skoy) (f skox)) 1 (= (f skox) 0) 1 (= 0 (f skoy)))))))))))) (=>+ 1 qbody))))
  (prf0 (let ((itef0 (ite (<= 0 0) 0 1))) (res (= (f 0) itef0) (expand (f 0)) (res (= itef0 0) (res (<= 0 0) (res (< 0 0) (total 0 0) (farkas 1 (< 0 0))) (ite1 itef0)) (trans (f 0) itef0 0)))))
  (prf100 (let ((itef100 (ite (<= 100 0) 0 1))) (res (= (f 100) itef100) (expand (f 100)) (res (= itef100 1) (res (<= 100 0) (ite2 itef100) (farkas 1 (<= 100 0))) (trans (f 100) itef100 1))))))
  (res (= (f 0) 0) prf0 (res (= (f 100) 1) prf100 (res quant (res qbody prfqbody (forall+ quant)) (and+ (and quant (= (f 0) 0) (= (f 100) 1))))))))))))
```

proof (by smtinterpol):

```
((refine-fun f ((@p0 Int)) (ite (<= @p0 0) 0 1)) (let ((.cse1 (choose (x Int) (not (forall ((y Int)) (=> (<= (+ x (* (- 1) y)) 0) (<= (+ (ite (<= x 0) 0 1) (* (- 1) (ite (<= y 0) 0 1))) 0))))))) (let ((.cse133 (ite (<= .cse1 0) 0 1))) (let ((.cse0 (choose (y Int) (not (=> (<= (+ .cse1 (* (- 1) y)) 0) (<= (+ .cse133 (* (- 1) (ite (<= y 0) 0 1))) 0)))))) ((define-fun @skolem.y.1 () .cse0) ((define-fun @skolem.x.0 () .cse1) (! (let ((.cse3 (<= @skolem.y.1 0))) (let ((.cse8 (ite .cse3 0 1)) (.cse17 (<= @skolem.x.0 0))) (let ((.cse33 (ite .cse17 0 1)) (.cse47 (* (- 1) .cse8))) (let ((.cse69 (+ .cse33 .cse47)) (.cse65 (+ @skolem.x.0 (* (- 1) @skolem.y.1)))) (let ((.cse49 (< 0 0)) (.cse61 (<= .cse65 0)) (.cse26 (<= .cse69 0))) (let ((.cse45 (< 0 (- 1))) (.cse31 (+ .cse33 (- 1))) (.cse60 (=> .cse61 .cse26)) (.cse39 (= 0 0))) (let-proof ((.cse40 (refl 0)) (.cse52 (farkas 1 .cse49))) (let ((.cse11 (+ .cse8 (- 1))) (.cse24 (<= .cse31 0)) (.cse41 (= (- 1) (- 1))) (.cse23 (= .cse31 0)) (.cse21 (= .cse33 0)) (.cse30 (< 0 .cse31))) (let-proof ((.cse67 (! (let-proof ((.cse74 true+)) (res true .cse74 (let ((.cse75 (forall ((x Int) (y Int)) (=> (<= (+ x (* (- 1) y)) 0) (<= (+ (ite (<= x 0) 0 1) (* (- 1) (ite (<= y 0) 0 1))) 0))))) (let ((.cse79 (=> (<= (+ .cse1 (* (- 1) .cse0)) 0) (<= (+ .cse133 (* (- 1) (ite (<= .cse0 0) 0 1))) 0)))) (let-proof ((.cse80 (forall+ .cse75))) (res .cse75 ((define-fun @quantbody ((x Int) (y Int)) (=> (<= (+ x (* (- 1) y)) 0) (<= (+ (ite (<= x 0) 0 1) (* (- 1) (ite (<= y 0) 0 1))) 0))) (let ((.cse76 (= .cse60 .cse79))) (res .cse76 (res (= @skolem.y.1 .cse0) (expand @skolem.y.1) (res (= @skolem.x.0 .cse1) (expand @skolem.x.0) (let ((.cse77 (@quantbody @skolem.x.0 @skolem.y.1))) (res (= .cse77 .cse60) (expand (@quantbody @skolem.x.0 @skolem.y.1)) (res (= .cse60 .cse77) (symm .cse60 .cse77) (let ((.cse78 (@quantbody .cse1 .cse0))) (res (= .cse77 .cse78) (cong (@quantbody @skolem.x.0 @skolem.y.1) (@quantbody .cse1 .cse0)) (res (= .cse78 .cse79) (expand (@quantbody .cse1 .cse0)) (trans .cse60 .cse77 .cse78 .cse79))))))))) (res .cse79 (=-2 .cse76) .cse80)))) (let ((.cse81 (and .cse75 true true))) (res .cse81 (and+ .cse81) (let ((.cse95 (f 100)) (.cse102 (f 0))) (let ((.cse124 (forall ((x Int) (y Int)) (=> (<= x y) (<= (f x) (f y))))) (.cse96 (= .cse102 0)) (.cse86 (= .cse95 1))) (let ((.cse82 (and .cse124 .cse96 .cse86))) (let ((.cse84 (not .cse82))) (let ((.cse83 (not .cse81))) (res .cse83 (res .cse84 (not+ .cse84) (let ((.cse85 (= .cse84 .cse83))) (res .cse85 (res (= .cse82 .cse81) (let ((.cse88 (= 1 1))) (let-proof ((.cse89 (refl 1))) (res (= .cse86 true) (let ((.cse87 (= .cse88 true))) (res .cse87 (res true .cse74 (res .cse88 .cse89 (=+2 .cse87))) (res (= .cse86 .cse88) (res .cse88 .cse89 (res .cse86 (let ((.cse94 (<= 100 0))) (let ((.cse90 (ite .cse94 0 1))) (res (= .cse90 1) (let ((.cse91 (ite false 0 1))) (let-proof ((.cse92 false-)) (res (= .cse91 1) (res false (ite2 .cse91) .cse92) (res (= .cse90 .cse91) (res .cse88 .cse89 (res .cse39 .cse40 (let ((.cse93 (= .cse94 false))) (res .cse93 (res false (res .cse94 (=+1 .cse93) (farkas 1 .cse94)) .cse92) (cong (ite .cse94 0 1) (ite false 0 1)))))) (trans .cse90 .cse91 1))))) (res (= .cse95 .cse90) (expand (f 100)) (trans .cse95 .cse90 1))))) (cong (= .cse95 1) (= 1 1)))) (trans .cse86 .cse88 true)))) (res (= .cse96 true) (let ((.cse97 (= .cse39 true))) (res .cse97 (res true .cse74 (res .cse39 .cse40 (=+2 .cse97))) (res (= .cse96 .cse39) (res .cse39 .cse40 (res .cse96 (let ((.cse101 (<= 0 0))) (let ((.cse98 (ite .cse101 0 1))) (res (= .cse98 0) (let ((.cse99 (ite true 0 1))) (res (= .cse99 0) (res true .cse74 (ite1 .cse99)) (res (= .cse98 .cse99) (res .cse88 .cse89 (res .cse39 .cse40 (let ((.cse100 (= .cse101 true))) (res .cse100 (res true .cse74 (res .cse101 (res .cse49 (total 0 0) .cse52) (=+2 .cse100))) (cong (ite .cse101 0 1) (ite true 0 1)))))) (trans .cse98 .cse99 0)))) (res (= .cse102 .cse98) (expand (f 0)) (trans .cse102 .cse98 0))))) (cong (= .cse102 0) (= 0 0)))) (trans .cse96 .cse39 true)))) (let ((.cse103 (= .cse124 .cse75))) (res .cse103 (let ((.cse104 (forall ((x Int) (y Int)) (= (=> (<= x y) (<= (f x) (f y))) (=> (<= (+ x (* (- 1) y)) 0) (<= (+ (ite (<= x 0) 0 1) (* (- 1) (ite (<= y 0) 0 1))) 0)))))) (res .cse104 (let ((.cse119 (choose (x Int) (not (forall ((y Int)) (= (=> (<= x y) (<= (f x) (f y))) (=> (<= (+ x (* (- 1) y)) 0) (<= (+ (ite (<= x 0) 0 1) (* (- 1) (ite (<= y 0) 0 1))) 0)))))))) (let ((.cse118 (f .cse119)) (.cse114 (ite (<= .cse119 0) 0 1))) (let ((.cse117 (choose (y Int) (not (= (=> (<= .cse119 y) (<= .cse118 (f y))) (=> (<= (+ .cse119 (* (- 1) y)) 0) (<= (+ .cse114 (* (- 1) (ite (<= y 0) 0 1))) 0))))))) (let ((.cse115 (ite (<= .cse117 0) 0 1))) (let ((.cse122 (+ .cse119 (* (- 1) .cse117))) (.cse112 (+ .cse114 (* (- 1) .cse115))) (.cse116 (f .cse117))) (let ((.cse106 (<= .cse118 .cse116)) (.cse108 (<= .cse112 0)) (.cse105 (<= .cse119 .cse117)) (.cse107 (<= .cse122 0))) (res (= (=> .cse105 .cse106) (=> .cse107 .cse108)) (res (= .cse106 .cse108) (let ((.cse110 (<= .cse114 .cse115))) (let ((.cse109 (= .cse110 .cse108))) (res .cse109 (res .cse108 (res .cse110 (=+1 .cse109) (let ((.cse111 (< 0 .cse112))) (res .cse111 (total .cse112 0) (farkas 1 .cse110 1 .cse111)))) (res .cse110 (let ((.cse113 (< .cse115 .cse114))) (res .cse113 (total .cse114 .cse115) (farkas 1 .cse113 1 .cse108))) (=+2 .cse109))) (res (= .cse106 .cse110) (res (= .cse116 .cse115) (expand (f .cse117)) (res (= .cse118 .cse114) (expand (f .cse119)) (cong (<= .cse118 .cse116) (<= .cse114 .cse115)))) (trans .cse106 .cse110 .cse108))))) (let ((.cse120 (= .cse105 .cse107))) (res .cse120 (res .cse107 (res .cse105 (=+1 .cse120) (let ((.cse121 (< 0 .cse122))) (res .cse121 (total .cse122 0) (farkas 1 .cse105 1 .cse121)))) (res .cse105 (let ((.cse123 (< .cse117 .cse119))) (res .cse123 (total .cse119 .cse117) (farkas 1 .cse123 1 .cse107))) (=+2 .cse120))) (cong (=> .cse105 .cse106) (=> .cse107 .cse108))))) (forall+ .cse104)))))))) (res .cse75 (res .cse124 (=+1 .cse103) (let ((.cse125 (=> (<= .cse1 .cse0) (<= (f .cse1) (f .cse0))))) (res .cse125 (forall- (.cse1 .cse0) .cse124) (res .cse79 (let ((.cse126 (= .cse125 .cse79))) (res .cse126 (forall- (.cse1 .cse0) .cse104) (=-2 .cse126))) .cse80)))) (res .cse124 (let ((.cse128 (choose (x Int) (not (forall ((y Int)) (=> (<= x y) (<= (f x) (f y)))))))) (let ((.cse132 (f .cse128))) (let ((.cse129 (choose (y Int) (not (=> (<= .cse128 y) (<= .cse132 (f y))))))) (let ((.cse127 (=> (<= (+ .cse128 (* (- 1) .cse129)) 0) (<= (+ (ite (<= .cse128 0) 0 1) (* (- 1) (ite (<= .cse129 0) 0 1))) 0)))) (res .cse127 (forall- (.cse128 .cse129) .cse75) (let ((.cse130 (=> (<= .cse128 .cse129) (<= .cse132 (f .cse129))))) (res .cse130 (let ((.cse131 (= .cse130 .cse127))) (res .cse131 (forall- (.cse128 .cse129) .cse104) (=-1 .cse131))) (forall+ .cse124)))))))) (=+2 .cse103))))) (cong (and .cse124 .cse96 .cse86) (and .cse75 true true)))))))) (cong (not .cse82) (not .cse81))) (=-2 .cse85)))) (not- .cse83))))))))))))))) :proves (- .cse60 + .cse82) :input)) (.cse42 (refl (- 1))) (.cse22 (ite1 .cse33)) (.cse53 (farkas 1 .cse45))) (let ((.cse2 (= .cse11 0)) (.cse34 (<= 1 .cse69)) (.cse12 (= 0 .cse11))) (let-proof ((.cse25 (! (res .cse39 .cse40 (res .cse41 .cse42 (res .cse30 (total .cse31 0) (res .cse49 (let ((.cse70 (= .cse30 .cse49))) (res .cse70 (res .cse23 (let ((.cse71 (+ 1 (- 1)))) (res (= .cse31 .cse71) (res (= .cse33 1) (res .cse45 (let ((.cse72 (= .cse30 .cse45))) (res .cse72 (res (= .cse31 (- 1)) (let ((.cse73 (+ 0 (- 1)))) (res (= .cse31 .cse73) (res .cse21 (res .cse17 (ite2 .cse33) .cse22) (cong (+ .cse33 (- 1)) (+ 0 (- 1)))) (res (= .cse73 (- 1)) (poly+ .cse73 (- 1)) (trans .cse31 .cse73 (- 1))))) (cong (< 0 .cse31) (< 0 (- 1)))) (=-2 .cse72))) .cse53) (cong (+ .cse33 (- 1)) (+ 1 (- 1)))) (res (= .cse71 0) (poly+ .cse71 0) (trans .cse31 .cse71 0)))) (cong (< 0 .cse31) (< 0 0))) (=-2 .cse70))) .cse52)))) :proves (+ .cse24) :input)) (.cse13 (symm 0 .cse11)) (.cse35 (total-int .cse69 0)) (.cse58 (! (res .cse60 (! (=>+ 1 .cse60) :proves (+ .cse60 - .cse26) :input) .cse67) :proves (- .cse26 + .cse82) :rup))) (res .cse2 (! (let ((.cse4 (= .cse8 1))) (let-proof ((.cse5 (ite2 .cse8))) (res .cse3 (! (res .cse4 .cse5 (let ((.cse6 (= .cse4 .cse2))) (res .cse6 (res .cse2 (res .cse4 (=+1 .cse6) (let ((.cse7 (= 1 .cse8))) (res .cse7 (symm 1 .cse8) (let ((.cse9 (< .cse11 0))) (res .cse9 (let ((.cse10 (< 0 .cse11))) (res .cse10 (trichotomy .cse11 0) (farkas 1 .cse10 1 .cse4))) (farkas 1 .cse9 1 .cse7)))))) (res .cse4 (res .cse12 .cse13 (let ((.cse14 (< .cse8 1))) (res .cse14 (let ((.cse15 (< 1 .cse8))) (res .cse15 (trichotomy .cse8 1) (farkas 1 .cse15 1 .cse2))) (farkas 1 .cse14 1 .cse12)))) (=+2 .cse6))) (=-2 .cse6)))) :proves (+ .cse2 + .cse3) :input) (! (let ((.cse68 (+ @skolem.y.1 (* (- 1) @skolem.x.0) 1))) (let ((.cse18 (<= 1 .cse68)) (.cse16 (<= .cse68 0))) (let-proof ((.cse19 (total-int .cse68 0))) (res .cse16 (res .cse17 (! (res .cse18 .cse19 (let ((.cse20 (<= 1 @skolem.x.0))) (res .cse20 (total-int @skolem.x.0 0) (farkas 1 .cse20 1 .cse18 1 .cse3)))) :proves (+ .cse17 + .cse16 - .cse3) :LA ((- 1) (- 1) 1)) (! (res .cse21 (! .cse22 :proves (+ .cse21 - .cse17) :input) (! (res .cse23 (! (res .cse24 .cse25 (res .cse26 (let ((.cse57 (+ .cse8 1))) (let ((.cse36 (<= 1 .cse57)) (.cse27 (<= .cse57 0))) (let-proof ((.cse37 (total-int .cse57 0))) (res .cse27 (let ((.cse28 (<= .cse33 0))) (res .cse28 (! (let ((.cse29 (< .cse31 0))) (res .cse29 (res .cse30 (trichotomy .cse31 0) (farkas 1 .cse30 1 .cse24)) (let ((.cse32 (<= 1 .cse33))) (res .cse32 (total-int .cse33 0) (farkas 1 .cse32 1 .cse29))))) :proves (+ .cse28 + .cse23 - .cse24) :trichotomy) (! (res .cse34 .cse35 (res .cse36 .cse37 (farkas 1 .cse36 1 .cse34 1 .cse28))) :proves (+ .cse27 + .cse26 - .cse28) :LA ((- 1) (- 1) 1)))) (! (let ((.cse43 (< 0 .cse47)) (.cse38 (<= .cse47 0))) (let-proof ((.cse44 (total .cse47 0))) (res .cse38 (res .cse39 .cse40 (res .cse41 .cse42 (res .cse43 .cse44 (res .cse45 (let ((.cse46 (= .cse43 .cse45))) (res .cse46 (res (= .cse47 (- 1)) (let ((.cse48 (* (- 1) 1))) (res (= .cse47 .cse48) (res .cse4 (res .cse49 (let ((.cse50 (= .cse43 .cse49))) (res .cse50 (res (= .cse47 0) (let ((.cse51 (* (- 1) 0))) (res (= .cse47 .cse51) (res (= .cse8 0) (res .cse3 .cse5 (ite1 .cse8)) (cong (* (- 1) .cse8) (* (- 1) 0))) (res (= .cse51 0) (poly* .cse51 0) (trans .cse47 .cse51 0)))) (cong (< 0 .cse47) (< 0 0))) (=-2 .cse50))) .cse52) (cong (* (- 1) .cse8) (* (- 1) 1))) (res (= .cse48 (- 1)) (poly* .cse48 (- 1)) (trans .cse47 .cse48 (- 1))))) (cong (< 0 .cse47) (< 0 (- 1)))) (=-2 .cse46))) .cse53)))) (let ((.cse54 (not .cse27))) (let-proof ((.cse56 (not- .cse54))) (res .cse54 (let ((.cse55 (= .cse38 .cse54))) (res .cse55 (res .cse54 (res .cse38 (=+1 .cse55) (res .cse27 (not+ .cse54) (farkas 1 .cse38 1 .cse27))) (res .cse38 (res .cse43 .cse44 (res .cse27 (res .cse36 .cse37 (farkas 1 .cse43 1 .cse36)) .cse56)) (=+2 .cse55))) (=-2 .cse55))) .cse56)))))) :proves (- .cse27) :input))))) .cse58)) :proves (+ .cse23 + .cse82) :rup) (! (let ((.cse59 (= 0 .cse31))) (res .cse59 (symm 0 .cse31) (farkas 1 .cse21 1 .cse59))) :proves (- .cse21 - .cse23) :LA (1 (- 1)))) :proves (- .cse21 + .cse82) :rup)) :proves (- .cse17 + .cse82) :rup)) (! (res .cse60 (! (res .cse61 (=>+ 0 .cse60) (let ((.cse62 (not .cse16))) (let-proof ((.cse66 (not- .cse62))) (res .cse62 (let ((.cse63 (= .cse61 .cse62))) (res .cse63 (res .cse62 (res .cse61 (=+1 .cse63) (res .cse16 (not+ .cse62) (farkas 1 .cse61 1 .cse16))) (res .cse61 (let ((.cse64 (< 0 .cse65))) (res .cse64 (total .cse65 0) (res .cse16 (res .cse18 .cse19 (farkas 1 .cse64 1 .cse18)) .cse66))) (=+2 .cse63))) (=-2 .cse63))) .cse66)))) :proves (+ .cse60 - .cse16) :input) .cse67) :proves (- .cse16 + .cse82) :rup))))) :proves (- .cse3 + .cse82) :rup)))) :proves (+ .cse2 + .cse82) :rup) (res .cse24 .cse25 (res .cse26 (! (res .cse12 .cse13 (res .cse34 .cse35 (farkas 1 .cse34 1 .cse24 1 .cse12))) :proves (+ .cse26 - .cse24 - .cse2) :LA ((- 1) 1 (- 1))) .cse58)))))))))))))) :proves (+ .cse82) :rup)))))))
```