<h1 id="resolute-a-simple-proof-format-for-smt-lib">RESOLUTE – A Simple
Proof Format for SMT-LIB</h1>
<p>The SMT-LIB standard defines a command for requesting proofs from
solvers, but it does not prescribe how these proofs should be
represented. Different solvers therefore use different proof
formats.</p>
<p>RESOLUTE is the proof format used by SMTInterpol. It is a low-level,
resolution-based format designed to be simple, explicit, and easy to
check. Proofs are represented as S-expressions and closely follow
SMT-LIB syntax wherever possible.</p>
<p>RESOLUTE proofs use the resolution rule to derive the empty clause
from the asserted formulas in the input and a fixed set of axioms for
logical and theory reasoning. The format is intentionally minimal:
complex reasoning is reduced to resolution steps over explicitly stated
axioms.</p>
<p>We have a <a
href="https://ultimate.informatik.uni-freiburg.de/smtinterpol/online/proof.html">proof
checker</a> for these proofs.</p>
<h2 id="resolution-proofs">Resolution proofs</h2>
<p>A RESOLUTE proof is given as a tree of subproofs. Each subproof
establishes the validity of a clause. A <em>clause</em> is a set of
literals and semantically represents the disjunction of these literals.
A <em>literal</em> is a positive or negative atom and an <em>atom</em>
is a Boolean SMT-LIB term, in other words, an SMT-LIB formula.</p>
<p>We use <code>+ t</code> to denote the positive literal for the term
<code>t</code> and <code>- t</code> for the negative literal. A clause
is denoted by an S-expression <code>( +/- t1 ... +/- tn )</code>. As
usual, a positive literal represents the fact that the term is true, a
negative literal that the term is false, and a clause represents the
fact that at least one of its literals holds.</p>
<p>A resolution proof is a proof of the unsatisfiability of an SMT-LIB
input script. It is given as a proof tree proving the empty clause,
where the internal nodes of the proof tree apply the resolution rule and
the leaves of the tree are the assumptions from the SMT-LIB input script
and logical or theory-specific axioms.</p>
<h3 id="resolution-rule">Resolution Rule</h3>
<p>The only inference rule in RESOLUTE is binary resolution. If
<code>proof1</code> proves a clause
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>
and <code>proof2</code> proves a clause
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>2</mn></msub><annotation encoding="application/x-tex">C_2</annotation></semantics></math>,
then the resolution with the pivot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
produces a proof of the clause
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>\</mo><mo stretchy="false" form="prefix">{</mo><mi>+</mi><mi>t</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo><mo>∪</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo>\</mo><mo stretchy="false" form="prefix">{</mo><mi>−</mi><mi>t</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(C_1\setminus \{+t\}) \cup (C_2\setminus\{-t\})</annotation></semantics></math>
where the complementary literals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>+</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">+ t</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">- t</annotation></semantics></math>
are removed from the respective clauses. The resolution step is written
as <code>(res t proof1 proof2)</code>. Clauses are treated as sets of
literals; therefore, literals occurring in both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>2</mn></msub><annotation encoding="application/x-tex">C_2</annotation></semantics></math>
occur only once in the conclusion. Strictly speaking, the resolution
rule is sound even when the clauses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>2</mn></msub><annotation encoding="application/x-tex">C_2</annotation></semantics></math>
do not contain the pivot literal; however, the proof checker will issue
a warning in that case.</p>
<h3 id="assumptions">Assumptions</h3>
<p>Each input formula denoted by <code>(assert t)</code> in the SMT-LIB
benchmark can be used as an assumption in the proof. The assumption is
denoted by the S-expression <code>(assume t)</code> and proves the unit
clause <code>( + t )</code>. Assumptions together with axioms form the
leaves of the proof tree.</p>
<h3 id="axioms">Axioms</h3>
<p>In addition to assumptions, RESOLUTE uses a fixed collection of
axioms that encode the semantics of logical operators and background
theories.</p>
<p>Each axiom is represented as a clause that is universally valid.
These axioms serve as the basic building blocks from which all reasoning
is derived. An axiom is written as a proof term
<code>(axiom-name parameter …)</code> that proves a tautological
clause.</p>
<p>In particular, the core theory defines the axioms for the logical
operators. As an example, the axiom <code>(or+ 1 (or t0 t1 t2))</code>
where <code>t0</code>, <code>t1</code>, and <code>t2</code> are
arbitrary terms is a proof for the valid clause
<code>( +(or t0 t1 t2) - t1 )</code>.</p>
<h2 id="axioms-for-core-theory">Axioms for core theory</h2>
<p>The meaning of logical operators is expressed by a set of core axioms
that are available in every SMT-LIB theory. The axioms explicitly
support associative SMT-LIB operators like <code>and</code>,
<code>or</code>, <code>=&gt;</code> with more than two arguments.</p>
<p>The following block is a schematic summary; the precise axioms are
given in “Core Axioms” below. Axioms are written as
<code>axiom-name: (clause)</code>.</p>
<pre><code>; logical operators
true+: ( + true )                      false-: ( - false )
 not+: ( +(not p0) + p0 )                not-: ( -(not p0) - p0 )
 and+: ( +(and p0 … pn) - p0 … - pn )    and-: ( -(and p0 … pn) + pi )
  or+: ( +(or p0 … pn) - pi )             or-: ( -(or p0 … pn) + p0 … + pn )
  =&gt;+: ( +(=&gt; p0 … pn) +/- pi )           =&gt;-: ( -(=&gt; p0 … pn) - p0 … + pn )
  =+1: ( +(= p0 p1) + p0 + p1 )           =-1: ( -(= p0 p1) + p0 - p1 )
  =+2: ( +(= p0 p1) - p0 - p1 )           =-2: ( -(= p0 p1) - p0 + p1 )
 xor+: ( +(xor l1) +(xor l2) -(xor l3) ) xor-: ( -(xor l1) -(xor l2) -(xor l3) )
    where each term in l1,l2,l3 occurs an even number of times.

; quantifiers
  forall+: ( +(forall (x) (F x)) -(F (choose (x) (F x))) )
  forall-: ( -(forall (x) (F x)) +(F t) )
  exists+: ( +(exists (x) (F x)) -(F t) )
  exists-: ( -(exists (x) (F x)) +(F (choose (x) (F x))) )

; equality axioms
     refl: ( +(= t t) )                  symm: ( +(= t0 t1) -(= t1 t0) )
    trans: ( +(= t0 tn) -(= t0 t1) … -(= tn-1 tn) )
     cong: ( +(= (f t0 … tn) (f t&#39;0 … t&#39;n)) -(= t0 t&#39;0) … -(= tn t&#39;n) )
       =+: ( +(= t0 … tn) -(= t0 t1) … -(= tn-1 tn) )
       =-: ( -(= t0 … tn) +(= ti tj) )
distinct+: ( +(distinct t0 … tn) +(= t0 t1) … +(= t0 tn) … +(= tn-1 tn) )
distinct-: ( -(distinct t0 … tn) -(= ti tj) )   where i != j

; ite, define-fun, annotations
  ite1: ( +(= (ite t0 t1 t2) t1) - t0 )  ite2: ( +(= (ite t0 t1 t2) t2) + t0 )
  del!: ( +(= (! t :annotation…) t) )
expand: ( +(= (f t0 … tn) (let ((x0 t0)…(xn tn)) d)) )
   where f is defined by (define-fun f ((x0 τ0)…(xn τn)) τ d)</code></pre>
<p>A detailed explanation of the axioms will be given in the section
“Core Axioms” below.</p>
<h2 id="syntactic-extensions">Syntactic extensions</h2>
<p>Conceptually a resolution proof is just a huge proof term applying
the resolution rule <code>res</code> to axioms and assumptions. However,
there are a few important extensions to concisely express large
proofs.</p>
<h3 id="let-terms">let terms</h3>
<p>A large proof may use the same large term multiple times. These large
terms can be shared between different clauses in the proof. To express
proofs in a concise manner, we support the <code>let</code> syntax from
SMT-LIB to bind terms to variables. Such <code>let</code> terms are seen
as syntactic sugar and are equal to their expanded form, i.e., no proof
rule is required to expand a <code>let</code>. In particular, the
resolution rule will also remove the pivot literal from the proved
clause if the pivot terms are only identical after let expansion.</p>
<p>To bind a proof to a variable, the <code>let-proof</code> keyword is
used with the same syntax as <code>let</code>. This can be used to avoid
repeating the same subproof multiple times. This proof variable may then
be used wherever a proof is expected, e.g., as arguments of the
resolution rule.</p>
<p>The <code>let-proof</code> syntax is also useful for expressing the
proofs in a linear form. A solver may choose to print its proof
incrementally by binding each learned clause to a variable until the
empty clause is derived:</p>
<pre><code>(let-proof ((C1 (assume …)))
(let-proof ((C2 (res … C1 …)))
…
 C100 ; empty clause
)…)</code></pre>
<h3 id="function-definitions">Function definitions</h3>
<p>The proof format also supports custom defined functions that are only
used inside the proof. This is useful for auxiliary functions that are
created by Skolemization or by CNF conversion of quantified formulas.
The syntax for this is
<code>((define-fun f ((x0 τ0)…(xn τn)) d) subproof)</code> where
subproof may use the function symbol <code>f</code> and the
<code>cong</code> and <code>expand</code> axioms for this function
symbol.</p>
<h3 id="extended-resolution">Extended resolution</h3>
<p>The proof calculus trivially supports extended resolution, where a
fresh atom <code>p</code> is introduced that represents
<code>(and p0 p1)</code> and the three clauses
<code>( - p0 - p1 + p )</code>, <code>( - p + p0 )</code>, and
<code>( - p + p1 )</code> are added. This is facilitated by the
<code>let</code> syntax and the axioms for logical operators as
follows:</p>
<pre><code>(let ((p (and p0 p1)))
  (let-proof ((C1 (and+ p))
              (C2 (and- 0 p))
              (C3 (and- 1 p)))
    …))</code></pre>
<p>Resolution proofs are usually only refutation complete, i.e., they
can prove the empty clause if the conjunction of the input clauses is
unsatisfiable. However, the addition of the core axioms makes the
calculus complete in the sense that for every valid SMT-LIB formula
<code>t</code> there is a proof that proves the unit clause
<code>( + t )</code>.</p>
<p>The proof calculus does not support RUP proofs directly. They need to
be converted to applications of <code>res</code> by explicitly listing
the clauses and pivot term used in the unit propagation subproof. More
importantly, DRAT proofs are not supported and there is no syntax for
deleting clauses. Instead they need to be converted to extended
resolution (which blows up the proof quadratically). On the other hand,
this simplifies the proof checker, which would otherwise need to
rediscover the necessary clauses and subproofs.</p>
<h2 id="example-proof-eq-diamond2">Example Proof: eq-diamond2</h2>
<p>We give an example proof of the following simple benchmark from the
SMT-LIB benchmark library.</p>
<pre class="smt2"><code>(set-option :produce-proofs true)
(set-logic QF_UF)
(declare-sort U 0)
(declare-fun x0 () U)
(declare-fun y0 () U)
(declare-fun z0 () U)
(declare-fun x1 () U)
(declare-fun y1 () U)
(declare-fun z1 () U)
(assert (and (or (and (= x0 y0) (= y0 x1)) (and (= x0 z0) (= z0 x1))) (not (= x0 x1))))
(check-sat)
(get-proof)</code></pre>
<p>A valid output for this benchmark would be the following.</p>
<pre class="smt2"><code>unsat
(let ((t1 (= x0 y0))
      (t2 (= y0 x1))
      (t3 (= x0 z0))
      (t4 (= z0 x1))
      (t5 (= x0 x1)))
(let ((t6 (and t1 t2))
      (t7 (and t3 t4))
      (t8 (not t5)))
(let ((t9 (or t6 t7)))
(let ((t10 (and t9 t8)))
(let-proof ((C0 (assume t10)))
(let-proof ((C1 (res t9 (res t10 C0 (and- 0 t10)) (or- t9))))
(let-proof ((C2 (res t8 (res t10 C0 (and- 1 t10)) (not- t8))))
(let-proof ((C3 (and- 0 t6)))
(let-proof ((C4 (and- 1 t6)))
(let-proof ((C5 (and- 0 t7)))
(let-proof ((C6 (and- 1 t7)))
(let-proof ((C7 (res t5 (res t1 C3 (res t2 C4 (trans x0 y0 x1))) C2)))
    (res t5 (res t6 (res t7 C1 (res t4 C6 (res t3 C5 (trans x0 z0 x1)))) C7) C2)
))))))))))))</code></pre>
<p>As mentioned earlier, the proof follows mostly the syntax of SMT-LIB
terms. In particular, it uses <code>let</code> and
<code>let-proof</code> to bind terms and subproofs to variables. We now
explain how such a proof can be constructed.</p>
<h3 id="introducing-names-for-subterms">Introducing names for
subterms</h3>
<p>The first ten lines define names for the subterms of the formula from
bottom-up. Note that <code>t10</code> is the asserted formula in the
input file (after expanding <code>let</code> bindings). It is not
required to introduce an identifier for every subterm, but doing so
helps keep the proof small.</p>
<h3 id="cnf-conversion">CNF conversion</h3>
<p>Then <code>C0</code> is defined, which is an input clause. Using the
<code>assume</code> rule, an input clause can be proved as a unit
clause. As usual, a clause is a list of literals, which are atoms with
positive or negative polarity. In our proof calculus, the atoms are
SMT-LIB terms of type Boolean. Thus, the input formula is represented by
a unit clause containing one positive atom that is the asserted
term.</p>
<p>Every proof rule produces a proof of a clause. The
<code>assume</code> rule produces the proof that the unit clause
<code>( + t10 )</code> holds. Clauses are written by listing the
literals in parentheses and the <code>+</code> indicates that the
literal has positive polarity. This proof is then assigned to the
variable <code>C0</code> so it can be referenced in later proofs.</p>
<p>The next step is to convert the input formula into CNF. We use
<code>C1</code>–<code>C7</code> for the clauses resulting from the
conversion (or more precisely, they are the proofs of the clauses of the
CNF). Let us look at how this is done. The input formula
<code>t10</code> is</p>
<pre><code>(and (or t6 t7) (not t5))</code></pre>
<p>Thus, we want to split it into <code>C1: ( + t6 + t7 )</code> and
<code>C2: ( - t5 )</code>. To split the <code>and</code> formula, we use
the <code>and-</code> elimination rule. In this example the axiom
<code>(and- 0 t10)</code> is used to prove <code>t9</code> from
<code>t10</code>. Note that <code>t10</code> is just an abbreviation for
<code>(and t9 t8)</code> and that <code>t9</code> is the argument at
index 0. So the axiom <code>(and- 0 t10)</code> proves the tautology
clause <code>( - t10 + t9 )</code>, which states that <code>t10</code>
implies <code>t9</code>. By resolving this clause with the input formula
<code>t10</code>, we get a proof of <code>t9</code>. The resolution is
written as <code>(res t10 C0 (and- 0 t10))</code>, where
<code>t10</code> is the pivot literal, <code>C0</code> is a proof of a
clause containing it positively, and <code>(and- 0 t10)</code> a proof
containing it negatively. The result is a proof for
<code>( + t9 )</code>.</p>
<p>The next step is to eliminate <code>(or t6 t7)</code>, that is
<code>t9</code>, using the <code>or-</code> elimination rule. The axiom
<code>(or- t9)</code> proves the tautology clause
<code>( - t9 + t6 + t7 )</code>. Resolving it with the previous proof on
the pivot <code>t9</code>, we obtain <code>C1</code> which is a proof of
<code>( + t6 + t7 )</code>.</p>
<pre><code>(let-proof ((C1 (res t9 (res t10 C0 (and- 0 t10)) (or- t9))))</code></pre>
<p>Similarly we use the other <code>and-</code> elimination rule
<code>(and- 1 t10)</code> and the <code>not-</code> elimination rule
<code>(not- t8)</code> to obtain from <code>C0</code> the clause
<code>C2</code> that proves <code>( - t5 )</code>.</p>
<pre><code>(let-proof ((C2 (res t8 (res t10 C0 (and- 1 t10)) (not- t8))))</code></pre>
<p>Furthermore, we add the clauses of the Plaisted–Greenbaum encoding
<code>C3</code>–<code>C6</code>. These clauses are simply the
<code>and-</code> elimination clauses, but this time applied to
<code>(and t1 t2)</code> and <code>(and t3 t4)</code>. This gives us the
full CNF of the input:</p>
<pre><code>C1: ( + t6 + t7 )
C2: ( - t5 )
C3: ( - t6 + t1 )
C4: ( - t6 + t2 )
C5: ( - t7 + t3 )
C6: ( - t7 + t4 )</code></pre>
<h3 id="smt-solving">SMT solving</h3>
<p>The only unit clause <code>C2</code> propagates <code>- t5</code>. We
assume the DPLL engine now decides the literal <code>+ t6</code> and
propagates <code>+ t1</code> and <code>+ t2</code> by unit propagation.
Then the theory solver finds the conflict involving transitivity:</p>
<pre><code>(trans x0 y0 x1): ( - t1 - t2 + t5 )</code></pre>
<p>By definition <code>t1</code> is <code>(= x0 y0)</code>,
<code>t2</code> is <code>(= y0 x1)</code> and <code>t5</code> is
<code>(= x0 x1)</code>, so the transitivity axiom for
<code>x0 = y0 = x1</code> has exactly this form.</p>
<p>CDCL now explains the conflict, yielding
<code>C7: ( - t6 )</code></p>
<pre><code>(let-proof ((C7 (res t5 (res t2 C4 (res t1 C3 (trans x0 y0 x1))) C2)))</code></pre>
<p>Now unit propagation derives <code>- t6</code>, <code>+ t7</code>,
<code>+ t3</code>, and <code>+ t4</code>, and again a theory conflict is
found:</p>
<pre><code>(trans x0 z0 x1): ( - t3 - t4 + t5 )</code></pre>
<p>The explanation of this conflict yields the empty clause:</p>
<pre><code>(res t5 (res t6 (res t7 C1 (res t4 C6 (res t3 C5 (trans x0 z0 x1)))) C7) C2)</code></pre>
<p>This concludes the proof.</p>
<h2 id="grammar">Grammar</h2>
<p>The grammar for proofs builds on the grammar for ⟨numeral⟩, ⟨term⟩,
⟨sort⟩, ⟨symbol⟩, ⟨sorted_var⟩, and ⟨attribute⟩ from the SMT-LIB
standard, version 2.6. It is given below:</p>
<pre><code>⟨term_or_proof⟩ ::= ⟨term⟩ | ⟨proof⟩
⟨polarity⟩ ::= + | -
⟨literal⟩ ::= ⟨polarity⟩ ⟨term⟩
⟨clause⟩ ::= ( ⟨literal⟩ ⃰ )
⟨proof⟩ ::= (res ⟨term⟩ ⟨proof⟩ ⟨proof⟩)
          | (let ((⟨symbol⟩ ⟨term⟩)⁺) ⟨proof⟩)
          | (let-proof ((⟨symbol⟩ ⟨proof⟩)⁺) ⟨proof⟩)
          | ⟨symbol⟩
          | ((define-fun ⟨symbol⟩ (⟨sorted_var⟩⁺) ⟨sort⟩ ⟨term⟩) ⟨proof⟩)
          | ((declare-fun ⟨symbol⟩ (⟨sort⟩⁺) ⟨sort⟩) ⟨proof⟩)
          | ((refine-fun ⟨symbol⟩ (⟨sorted_var⟩⁺) ⟨sort⟩ ⟨term⟩) ⟨proof⟩)
          | (assume ⟨term⟩)
          | (oracle ⟨clause⟩ ⟨attribute⟩ ⃰)
          | ⟨core-axiom⟩
          | ⟨arith-axiom⟩
          | ⟨datatype-axiom⟩
          | ⟨bitvector-axiom⟩</code></pre>
<p>As mentioned earlier, an atom is an SMT-LIB term. A literal is a term
with a polarity <code>+</code> or <code>-</code>. A clause is a set of
literals, written as a sequence enclosed in parentheses.</p>
<p>Every proof proves a clause. The proof produced by an SMT solver
should prove the empty clause. A proof may be constructed from
subproofs. For this purpose, a subproof may be bound to a symbol, so
that it can be reused efficiently.</p>
<p>The rule <code>(res t p1 p2)</code> is the resolution rule, the main
workhorse of this proof format. Here <code>p1</code> is a proof of some
clause
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>
and <code>p2</code> is a proof of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>2</mn></msub><annotation encoding="application/x-tex">C_2</annotation></semantics></math>.
The resulting proof term proves the clause
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo>\</mo><mo stretchy="false" form="prefix">{</mo><mi>+</mi><mi>t</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo><mo>∪</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>C</mi><mn>2</mn></msub><mo>\</mo><mo stretchy="false" form="prefix">{</mo><mi>−</mi><mi>t</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(C_1\setminus \{+ t\}) \cup (C_2\setminus\{- t\})</annotation></semantics></math>.
The order of <code>p1</code> and <code>p2</code> is important:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>1</mn></msub><annotation encoding="application/x-tex">C_1</annotation></semantics></math>
should contain the positive pivot literal, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mn>2</mn></msub><annotation encoding="application/x-tex">C_2</annotation></semantics></math>
the negative one. The proof checker warns if the pivot literal does not
occur in the corresponding clause but still accepts the proof.</p>
<p>The let binder <code>let ((x t)) p</code> binds the value of
<code>t</code> to a symbol <code>x</code>. Here <code>t</code> can be an
arbitrary term. The symbol <code>x</code> can then be used in terms as a
free variable. Similarly, the let binder
<code>let-proof ((x p1)) p</code> binds a proof <code>p1</code> to the
variable <code>x</code> and <code>x</code> can be referenced in
<code>p</code> using the ⟨symbol⟩ rule. The scope of <code>x</code> is
the proof <code>p</code> and the resulting proof proves the same clause
as <code>p</code>.</p>
<p>Proofs can also contain a <code>define-fun</code> declaration with
the same syntax as in SMT-LIB. This defines a function symbol for the
subproof, which may use the definition via the <code>expand</code>
axiom. The defined function symbol must not be used outside the
subproof. Similarly, <code>declare-fun</code> introduces an
uninterpreted function symbol.</p>
<p>There is also a <code>refine-fun</code> declaration which adds a
function definition to an already declared function. It is only allowed
at the outermost level of a satisfiability proof and is used to fix the
model for an uninterpreted function occurring in the benchmark.</p>
<p>The rule <code>(assume t)</code> proves the unit clause
<code>( + t )</code>. Its side condition (checked by the proof checker)
is that <code>t</code> was asserted in the input problem by an SMT-LIB
<code>assert</code> command.</p>
<p>The oracle rule can be used to introduce clauses that cannot be
easily explained. It should be used as a last resort if a full low-level
proof is too tedious or if the axioms for the theory are missing. The
proof checker allows any oracle clause but will warn about these
clauses.</p>
<p>The remaining rules correspond to the logical and theory axioms of
the proof format. Each of them creates a tautological clause. They are
given in the next section.</p>
<h2 id="core-axioms">Core Axioms</h2>
<p>The core axioms are ⟨proof⟩ objects that prove tautologies. They are
usually parametrized by ⟨term⟩ objects. We distinguish the following
categories.</p>
<h3 id="logical-axioms-elimination-and-introduction">Logical axioms –
elimination and introduction</h3>
<p>For every logical operator we have the usual elimination and
introduction rules. In our calculus they take the form of a clause where
the premises have negative polarity and the conclusion has positive
polarity. They are also identical to the clauses produced by Tseitin
encoding. The following lists the axioms and the corresponding clause
proved by each axiom. In this list <code>t, t0, …</code> denote terms,
<code>n, i, j</code> denote numerals. The elimination rules are
indicated by <code>-</code> and the introduction rules by
<code>+</code>.</p>
<pre><code>⟨core-axiom⟩ ::=
 | (false-)               ;( - false )
 | (true+)                ;( + true )
 | (not+ (not t))         ;( +(not t) + t )
 | (not- (not t))         ;( -(not t) - t )
 | (and+ (and t0 … tn))   ;( +(and t0 … tn) - t0 … - tn )
 | (and- i (and t0 … tn)) ;( -(and t0 … tn) + ti )       (for 0 &lt;= i &lt;= n)
 | (or+ i (or t0 … tn))   ;( +(or t0 … tn) - ti )        (for 0 &lt;= i &lt;= n)
 | (or- (or t0 … tn))     ;( -(or t0 … tn) + t0 … + tn )
 | (=&gt;+ i (=&gt; t0 … tn))   ;( +(=&gt; t0 … tn) + ti )        (for 0 &lt;= i &lt; n)
 | (=&gt;+ n (=&gt; t0 … tn))   ;( +(=&gt; t0 … tn) - tn )
 | (=&gt;- (=&gt; t0 … tn))     ;( -(=&gt; t0 … tn) - t0 … - tn-1 + tn )
 | (=+1 (= t0 t1))        ;( +(= t0 t1) + t0 + t1 )      (only for Boolean t0/t1)
 | (=+2 (= t0 t1))        ;( +(= t0 t1) - t0 - t1 )      (only for Boolean t0/t1)
 | (=-1 (= t0 t1))        ;( -(= t0 t1) + t0 - t1 )      (only for Boolean t0/t1)
 | (=-2 (= t0 t1))        ;( -(= t0 t1) - t0 + t1 )      (only for Boolean t0/t1)
 | …                      ;;; see next section</code></pre>
<h3 id="equality-rules">Equality rules</h3>
<p>We support the usual axioms of reflexivity, symmetry, transitivity
(with arbitrarily long chains), and congruence:</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (refl t):              ;( +(= t t) )
 | (symm t0 t1):          ;( +(= t0 t1) -(= t1 t0) )
 | (trans t0 … tn):       ;( +(= t0 tn) -(= t0 t1) … -(= tn-1 tn) )  (for n &gt;= 2)
 | (cong (f t0 … tn) (f t&#39;0 … t&#39;n))
                       ;( +(= (f t0 … tn) (f t&#39;0 … t&#39;n))
                       ;  -(= t0 t&#39;0) … -(= tn t&#39;n))</code></pre>
<p>Additionally we have elimination and introduction rules for equality
chains and for distinct:</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (=+ (= t0 … tn)):              ;( +(= t0 … tn) -(= t0 t1) … -(= tn-1 tn))
 | (=- i j (= t0 … tn)):          ;( -(= t0 … tn) +(= ti tj))
 | (distinct+ (distinct t0 … tn)) ;( +(distinct t0 … tn)
                                  ;  +(= t0 t1) … +(= t0 tn)
                                  ;  +(= t1 t2) … +(= t2 tn)…
                                  ;  +(= tn-1 tn))
              ; Note that these are the pairwise equalities (= ti tj) for i &lt; j.
 | (distinct- i j (distinct t0 … tn)); ( -(distinct t0 … tn) -(= ti tj))      (for i != j)</code></pre>
<p>The rules containing <code>i,j</code> have the implicit constraint
<code>0 &lt;= i &lt;= n</code>, <code>0 &lt;= j &lt;= n</code>. For
<code>=</code> we have n &gt;= 2. For <code>distinct</code> we have
<code>n &gt;= 1</code>.</p>
<h3 id="ite-rules">ite rules</h3>
<p>To support <code>ite</code> terms, we have two simple axioms
(<code>t0</code> is the condition).</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (ite1 (ite t0 t1 t2))   ;( - t0 +(= (ite t0 t1 t2) t1) )
 | (ite2 (ite t0 t1 t2))   ;( + t0 +(= (ite t0 t1 t2) t2) )</code></pre>
<h3 id="xor-rules">xor rules</h3>
<p>For efficient <code>xor</code> reasoning we allow arbitrary splitting
and reordering of the xor arguments between three xor terms. The rules
are</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (xor+ (t̅0) (t̅1) (t̅2))   ;( +(xor t̅0) +(xor t̅1) -(xor t̅2) )
 | (xor- (t̅0) (t̅1) (t̅2))   ;( -(xor t̅0) -(xor t̅1) -(xor t̅2) )</code></pre>
<p>where <code>t̅0, t̅1, t̅2</code> are three non-empty sequences of terms
that in total contain each term an even number of times. Furthermore, if
one of the sequences <code>t̅i</code> consists of only a single term
<code>ti</code> then the clause contains the atom <code>ti</code>
instead of the corresponding <code>xor</code> term. For example:</p>
<pre><code>(xor+ (t0 t1 t2) (t1) (t2 t0)): ( +(xor t0 t1 t2) + t1 -(xor t2 t0) )
(xor- (t t) (t t) (t t)):       ( -(xor t t) )</code></pre>
<p>Note that the last rule uses the fact that a clause is a set of
literals, so multiple occurrences of literals are implicitly
removed.</p>
<h3 id="quantifier-instantiation-and-skolemization">Quantifier
instantiation and Skolemization</h3>
<p>The rules for quantifier introduction and elimination bind the
quantified variables either to an arbitrary term or via the choose
operator (the Hilbert epsilon operator).</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (forall+ (forall ((x0 X0) … (xn Xn)) F))
    ;( +(forall ((x0 X0) … (xn Xn)) F)
    ;  -(let ((x0 (choose (x0 X0) (not (forall ((x1… xn Xn)) F)))))
    ;    (let ((x1 (choose (x1 X1) (not (forall ((x2… xn Xn)) F)))))
    ;     …
    ;     (let ((xn (choose (xn Xn)) (not F))) F)..)) )
 | (forall- (t0 … tn) (forall ((x0 X0) … (xn Xn)) F)):
    ;( -(forall ((x0 X0) … (xn Xn)) F) +(let ((x0 t0) … (xn tn)) F) )
 | (exists+ (t0 … tn) (exists ((x0 X0) … (xn Xn)) F)):
    ;( +(exists ((x0 X0) … (xn Xn)) F) -(let ((x0 t0) … (xn tn)) F) )
 | (exists- (exists ((x0 X0) … (xn Xn)) F))
    ;( -(exists ((x0 X0) … (xn Xn)) F)
    ;  +(let ((x0 (choose (x0 X0) (exists ((x1… xn Xn)) F))))
    ;    (let ((x1 (choose (x1 X1) (exists ((x2… xn Xn)) F))))
    ;     …
    ;      (let ((xn (choose (xn Xn)) F)) F)…)) )</code></pre>
<p>In forall- and exists+, <code>ti</code> has to be a term of sort
<code>Xi</code>.</p>
<h3 id="miscellaneous-rules">Miscellaneous rules</h3>
<p>For every symbol defined by <code>define-fun</code> (either in the
proof or in the benchmark), we have a rule that expands the function
definition. Assume <code>f</code> is defined as</p>
<pre><code>(define-fun f ((x0 X0) … (xn Xn)) X t)</code></pre>
<p>then the expand rule for <code>f</code> is</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (expand (f t0 … tn)) ;( +(= (f t0 … tn) (let ((x0 t0) … (xn tn)) t)))</code></pre>
<p>Note that the <code>:named</code> attribute is implicitly expanded to
<code>define-fun</code> according to the standard and therefore the
expand rule can also be used for named terms.</p>
<p>For some internal functions, the expand rule is also applicable. For
every function with the LEFTASSOC, RIGHTASSOC, CHAINABLE, or PAIRWISE
attribute and more than two arguments, <code>expand</code> applies the
transformation given by the SMT-LIB standard, e.g.:</p>
<pre><code>(expand (or t0 … tn)): ( +(= (or t0 … tn)
                              (or … (or t0 t1) … tn)))
(expand (=&gt; t0 … tn)): ( +(= (=&gt; t0 … tn)
                              (=&gt; t0 … (=&gt; tn-1 tn) … )))
(expand (&lt; t0 … tn)):  ( +(= (&lt; t0 … tn)
                              (and (&lt; t0 t1) … (&lt; tn-1 tn))))</code></pre>
<p>Theories have their own expand rules for some of the theory
functions, like <code>abs</code> or <code>(_ divisible k)</code>. These
are listed in the section describing the theory extensions.</p>
<p>We also have a simple rule to delete attributes from input terms:</p>
<pre><code>⟨core-axiom⟩ ::= …
 | (del! t :attributes…)  ;( +(= (! t :attributes…) t) )</code></pre>
<h2 id="equality-between-terms">Equality between terms</h2>
<p>A proof calculus needs to define which terms are intrinsically equal.
This equality relation needs to be decidable, but it should also be
simple for efficient implementation of proof checkers. To ensure
consensus on when a proof is correct, we need to formally define this
intrinsic equality.</p>
<p>Equality is used by the proof checker in two places. The first is for
the side condition of the <code>assume</code> rule, which requires that
the assumed term be equal to a formula asserted in the input problem.
The second is for the set operations in the resolution rule, which
remove the pivot literal from the clauses and eliminate duplicated
elements in the resolvent.</p>
<p>In type theory, equality is usually defined by α-, β-, δ-, …
reductions. Here we define our own reduction rules in the form of a
rewrite system. Two terms are equal if they are rewritten to the same
canonical term.</p>
<p>The rules are</p>
<pre><code>x → t                where x in the current context is bound to t by a let
(let (...) t) → t    where t contains no variable bound by let
|symbol| → symbol    where symbol is a valid SMT-LIB symbol
numeral → numeral.0  only for LRA/NRA logics where numeral has sort Real</code></pre>
<h3 id="discussion">Discussion</h3>
<p>The above rules are minimal to keep the canonicalization of terms
simple. The <code>let</code> rules are necessary for efficient proof
representation. The <code>|symbol|</code> rule should help solvers whose
internal representation may not differentiate between quoted and
unquoted terms.</p>
<p>The last rule for <code>numeral</code> is only used for matching the
input formula of the benchmark with the asserted formula in the proof.
It is necessary because, when bitvectors are present, a proof is parsed
as a term in the logic LIRA, since our bitvector rules use integers.
This means that every ⟨numeral⟩ in the input formula must be written as
the corresponding ⟨decimal⟩ in the proof.</p>
<p>Note that any change to these rules can make existing proofs invalid.
If new rules are added, this may cause resolution steps to become
superfluous and produce a warning that the pivot literal was not found
in the antecedent clause. This could be solved by making the resolution
rule more lenient, but such a change would make debugging faulty proofs
much harder, since then only the final emptiness check for the proved
clause would fail.</p>
<h3 id="clashing-variable-names">Clashing variable names</h3>
<p>For the rewrite system above, variable names can clash. As an
example, consider the following term.</p>
<pre><code>(exists ((x Int)) (let ((y x)) (exists (x Int) (not (= x y)))))</code></pre>
<p>When rewriting the above term using the let rules and replacing
<code>y</code> by its definition <code>x</code>, the proof validator
needs to remember that <code>x</code> refers to the variable bound by
the outer quantifier and not to the inner one. In particular, the above
term is not equal (not even equivalent) to the term</p>
<pre><code>(exists ((x Int)) (exists (x Int) (not (= x x))))</code></pre>
<p>Instead the term could be represented by</p>
<pre><code>(exists ((x₁ Int)) (exists (x₂ Int) (not (= x₂ x₁))))</code></pre>
<h2 id="extensions-for-other-theories">Extensions for other
theories</h2>
<p>When adding more theories, we need to add more axioms to support
these theories. Here we list the axioms for the theories that
SMTInterpol supports.</p>
<h3 id="array-theory">Array Theory</h3>
<p>We add the McCarthy axioms and an axiom for extensionality. We choose
the axiom with an explicit <code>@diff</code> operator that returns an
index witnessing a difference between two arrays.</p>
<pre><code>⟨array-axiom⟩ ::=
 | (selectstore1 a i v)   ;( +(= (select (store a i v) i) v) )
 | (selectstore2 a i j v) ;( +(= (select (store a i v) j) (select a j)) +(= i j) )
 | (extdiff a b)          ;( +(= a b) -(= (select a (@diff a b)) (select b (@diff a b))) )</code></pre>
<p>To support const arrays, one additional axiom is needed:</p>
<pre><code> | (const v i)            ;( +(= (select (@const v) i) v) )</code></pre>
<h3 id="arithmetic">Arithmetic</h3>
<p>For arithmetic we need to manipulate polynomials. Polynomials are
represented by an SMT-LIB term of the following form.</p>
<pre><code>  (+ (* c1 t11 … t1m) … (* cn tn1 … tnm))</code></pre>
<p>Here <code>c1</code>, …, <code>cn</code> are constants (⟨numeral⟩,
⟨decimal⟩, or integer/real numbers in canonical form). All
<code>(ti1 … tim)</code> are different multisets, and the head symbol of
<code>tij</code> is not <code>+</code> or <code>*</code>. All
<code>ci</code>, <code>tij</code> have the same type (<code>Real</code>
or <code>Int</code>). The constant <code>ci</code> may be omitted if it
is <code>1</code>, except if there are no other terms in the monomial.
The operators <code>*</code> and <code>+</code> are omitted if they have
only one argument. The zero polynomial is represented by
<code>0</code>.</p>
<p>When multiplying polynomials or adding them together, the usual rules
of distributivity, commutativity, and associativity are applied to bring
them into the above normal form again.</p>
<p>We have four rules that manipulate these polynomials. The first two
perform polynomial addition and multiplication:</p>
<pre><code>⟨arith-axiom⟩ ::=
 | (poly+ (+ a1 … an) a):  ;( +(= (+ a1 … an) a) )  where a1+…+an = a
 | (poly* (* a1 … an) a):  ;( +(= (* a1 … an) a) )  where a1*…*an = a
 | …</code></pre>
<p>Here <code>a1</code>, …, <code>an</code>, <code>a</code> are
polynomials. The side-condition <code>a1+…+an=a</code> states that
adding the polynomial <code>a1</code>, …, <code>an</code> yields a
polynomial equal to <code>a</code>, i.e., it has the same monomials with
the same coefficients, but may differ in term order. Similarly for
<code>a1*…*an=a</code>.</p>
<p>Then we have one rule for <code>to_real</code>:</p>
<pre><code>⟨arith-axiom⟩ ::= …
 | (to_real-def a)  ;( +(= (to_real a) a&#39;) )</code></pre>
<p>where <code>a</code> is a polynomial
<code>(+ … (* ci … tij …))</code> with integer coefficients and terms
and <code>a'</code> is the polynomial
<code>(+ … (* ci' … (to_real tij) …))</code> where <code>ci'</code> is
the real representation of the integer <code>ci</code>, i.e., an integer
<code>NUM</code> is replaced with <code>NUM.0</code> and
<code>(- NUM)</code> is replaced with <code>(- NUM.0)</code>. Every
other term <code>t</code> is replaced by <code>(to_real t)</code>.</p>
<p>The heart of the proof system is the following rule proving the
inconsistency of a set of inequalities by using Farkas’ Lemma. (Note
that this is only complete for linear arithmetic).</p>
<pre><code>⟨arith-axiom⟩ ::= …
 | (farkas c1 (&lt;=? a1 b1) … cn (&lt;=? an bn)): ( -(&lt;=? a1 b1) … -(&lt;=? an bn) )</code></pre>
<p>where <code>ci</code> are positive integers, <code>&lt;=?</code>
stands for <code>&lt;</code>, <code>&lt;=</code>, or <code>=</code>,
<code>ai</code>, <code>bi</code> are polynomials. The weighted sum of
these polynomials, <code>c1*(a1-b1) + … + cn*(an-bn)</code> is a
(rational or integer) constant <code>c</code> where
<code>c &gt;= 0</code>. If <code>c = 0</code>, then at least one
inequality must be strict. If some inequalities are over
<code>Int</code> and some are over <code>Real</code>, all inequalities
are implicitly converted to <code>Real</code> by converting all
coefficients in <code>ai</code>/<code>bi</code> to real constants and
replacing all terms <code>t</code> in <code>ai</code>/<code>bi</code>
with <code>(to_real t)</code>.</p>
<p>The remaining axioms work with arbitrary terms and do not require
adding or multiplying polynomials:</p>
<pre><code>⟨arith-axiom⟩ ::= …
 | (trichotomy a b)   ;( +(&lt; a b) +(= a b) +(&lt; b a) )
 | (total a b)        ;( +(&lt;= a b) +(&lt; b a) )</code></pre>
<p>The only side condition is that the terms in the clause type check.
For integer reasoning we use the following axiom that states that there
is no number between <code>c</code> and <code>c+1</code>:</p>
<pre><code>⟨arith-axiom⟩ ::= …
 | (total-int a c)    ;( +(&lt;= a c) +(&lt;= (c+1) a) )</code></pre>
<p>where <code>c</code> is an integer constant (NUMERAL or negated
NUMERAL) and <code>(c+1)</code> is the SMT-LIB representation of that
constant plus one. The term <code>a</code> is an arbitrary term of sort
<code>Int</code>. Note: an alternative would be to restrict the axiom to
<code>c = 0</code>; i.e., <code>(total-int a)</code> proves
<code>( +(&lt;= a 0) +(&lt;= 1 a) )</code></p>
<p>Also we need the following axioms for handling division and modulo.
The rules are for the theories that contain the corresponding function
symbols. Note that these rules are syntactic. No polynomial
normalization is performed in these rules.</p>
<pre><code>⟨arith-axiom⟩ ::= …
 | (/def a b1 … bn)  ;( +(= a (* b1 … bn (/ a b1 … bn))) +(= b1 0) … +(= bn 0) )
 | (div-low x d):    ;( +(&lt;= (* d (div x d)) x) +(= d 0) )
 | (div-high x d):   ;( +(&lt; x (+ (* d (div x d)) (abs d))) +(= d 0) )
 | (mod-def x d):    ;( +(= (mod x d) (- x (* d (div x d)))) +(= d 0) )
 | (to_int-low x):   ;( +(&lt;= (to_real (to_int x)) x) )
 | (to_int-high x):  ;( +(&lt; x (+ (to_real (to_int x)) 1.0)) )</code></pre>
<p>In addition to the axioms above, we also add new definitions for the
<code>expand</code> axioms. These are given in the following table:</p>
<pre><code>(define-fun - ((x Int)) Int (* (- 1) x))
(define-fun - ((x Real)) Real (* (- 1) x))
(define-fun - ((x Int) (y Int)) Int (+ x (* (- 1) y)))
(define-fun - ((x Real) (y Real)) Real (+ x (* (- 1.0) y)))
(define-fun &gt; ((x Int) (y Int)) Bool (&lt; y x))
(define-fun &gt; ((x Real) (y Real)) Bool (&lt; y x))
(define-fun &gt;= ((x Int) (y Int)) Bool (&lt;= y x))
(define-fun &gt;= ((x Real) (y Real)) Bool (&lt;= y x))
(define-fun abs ((x Int)) Int (ite (&lt; x 0) (- x) x))
(define-fun abs ((x Real)) Real (ite (&lt; x 0) (- x) x))
(define-fun (_ divisible c) ((x Int)) Bool (= x (* c (div x c))))
(define-fun is_int ((x Real)) Bool (= x (to_real (to_int x))))</code></pre>
<p>The other proof rules do not use the symbols <code>-</code>,
<code>/</code>, <code>&gt;=</code>, <code>&gt;</code>. A solver should
first rewrite them using these definitions and then only work with
<code>&lt;=</code>, <code>&lt;</code>, <code>*</code>, <code>+</code>.
Note that in <code>(divisible-def c x)</code> the constant
<code>c</code> must be a positive numeral larger than zero, to make the
term <code>((_ divisible c) x)</code> syntactically correct.</p>
<p>Also for every internal binary function in LIRA that takes two reals,
we define corresponding functions that take a mix of <code>Int</code>
and <code>Real</code> arguments and cast all integer arguments to
<code>Real</code>. This is supported by the <code>expand</code> rule and
works even if the function is used with more than two arguments. As an
example, for <code>(+ i0 r1 i2 r3)</code> where <code>i0</code>,
<code>i2</code> are terms of sort <code>Int</code> and <code>r1</code>,
<code>r3</code> are terms of sort <code>Real</code>, the
<code>expand</code> axiom looks like:</p>
<pre><code>(expand (+ i0 r1 i2 r3)): ( +(= (+ i0 r1 i2 r3)
                                (+ (to_real i0) r1 (to_real i2) r3)))</code></pre>
<p>Note that the axiom <code>farkas</code> is the only axiom with
negated literals. It can be used in a resolution proof to rewrite a
positive literal into an equivalent negated literal. On the other hand,
the axiom <code>total</code> and <code>total-int</code> can be used to
rewrite a negated literal into the equivalent positive literal.</p>
<h3 id="data-types">Data Types</h3>
<p>For reasoning about data types, the following rules are used:</p>
<pre><code>⟨datatype-axiom⟩ ::= …
 | (dt_project seli a1 … an)       ;( +(= (seli (cons a1 … an)) ai) )
 | (dt_cons cons x)                ;( -((_ is cons) x) +(= (cons (sel1 x) … (seln x)) x) )
 | (dt_test cons (cons a1 … an))   ;( +((_ is cons) (cons a1 … an)) )
 | (dt_test cons&#39; (cons a1 … an))  ;( -((_ is cons&#39;) (cons a1 … an)) )
 | (dt_exhaust x)                  ;( +((_ is cons1) x) … +((_ is consn) x) )
 | (dt_acyclic (cons …(cons… x …)…) x) ;( -(= (cons …(cons… x …)…) x) )
   ; where (cons …(cons… x …)…) is a term containing x, and around x
   ; only constructor functions appear.
 | (dt_match (match t …))
   ;( +(= (match t ((p1 x1) c1) …) (ite ((_ is p1) t) (let ((x1 (sel1 t))) c1) …)) )</code></pre>
<h3 id="bitvectors">Bitvectors</h3>
<p>The idea is to translate bitvectors into integer arithmetic. We use
the new functions <code>ubv_to_int</code> and <code>int_to_bv</code>
introduced in SMT-LIB version 2.7 to convert between integers and
bitvectors.</p>
<p>We have the following correspondences:</p>
<pre><code>⟨bitvector-axiom⟩ ::=
 | (int2ubv2int k t0)  ;( +(= (ubv_to_int ((_ int_to_bv k) t0)) (mod t0 2^k)) )
 | (int2sbv2int k t0)  ;( +(= (sbv_to_int ((_ int_to_bv k) t0)) (+ (mod (+ t0 2^(k-1)) 2^k) (- 2^(k-1)))) )
 | (ubv2int2bv t0)     ;( +(= ((_ int_to_bv k) (ubv_to_int t0)) t0) )
                       ; where t0 is of sort (_ BitVec k)</code></pre>
<p>In these axioms <code>2^k</code>, <code>2^(k-1)</code> stand for the
corresponding numerals, e.g., for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=3</annotation></semantics></math>
the axiom <code>(int2sbv2int 3 t0)</code> proves the clause
<code>( +(= (sbv_to_int ((_ int_to_bv 3) t0)) (+ (mod (+ t0 4) 8) (- 4))))</code>.
The axiom is syntactic, i.e., the term <code>(+ t0 4)</code> is not
simplified. In <code>(ubv2int2bv t0)</code> the width <code>k</code> is
implicitly determined by the sort of <code>t0</code>, which is
<code>(_ BitVec k)</code>. This is not possible for the other two axioms
because <code>t0</code> has sort <code>Int</code>.</p>
<p>The following definitions handle arithmetic:</p>
<pre><code>(define-fun bvadd ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (ubv_to_int x) (ubv_to_int y))))
(define-fun bvsub ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (ubv_to_int x) (* (- 1) (ubv_to_int y)))))
(define-fun bvneg ((x (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (* (- 1) (ubv_to_int x))))
(define-fun bvmul ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (* (ubv_to_int x) (ubv_to_int y))))
(define-fun bvudiv ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (ite (= (ubv_to_int y) 0) (- 1) (div (ubv_to_int x) (ubv_to_int y)))))
(define-fun bvurem ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   (ite (= (ubv_to_int y) 0) x ((_ int_to_bv k) (mod (ubv_to_int x) (ubv_to_int y)))))
(define-fun bvsdiv ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   (let ((ix (sbv_to_int x)) (iy (sbv_to_int y)))
   ((_ int_to_bv k) (ite (&lt; ix 0)
            (ite (&lt; iy 0) (div (- ix) (- iy)) (ite (= iy 0) 1 (- (div (- ix) iy))))
            (ite (&lt; iy 0) (- (div ix (- iy))) (ite (= iy 0) (- 1) (div ix iy)))))))
(define-fun bvsrem ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   (let ((ix (sbv_to_int x)) (iy (sbv_to_int y)))
   ((_ int_to_bv k) (ite (= iy 0) ix
            (ite (&lt; ix 0) (- (mod (- ix) iy)) (mod ix iy))))))
(define-fun bvsmod ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   (let ((ix (sbv_to_int x)) (iy (sbv_to_int y)))
   ((_ int_to_bv k) (ite (= iy 0) ix (ite (&lt; iy 0) (+ (mod (+ ix (- 1)) (- iy)) iy 1) (mod ix iy)))))
(define-fun bvnego ((x (_ BitVec k))) Bool
   (= (ubv_to_int x) 2^(k-1)))
(define-fun bvuaddo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (&lt;= 2^k (+ (ubv_to_int x) (ubv_to_int y))))
(define-fun bvsaddo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (or (&lt; (+ (sbv_to_int x) (sbv_to_int y)) 2^(k-1)) (&lt;= 2^(k-1) (+ (sbv_to_int x) (sbv_to_int y)))))
(define-fun bvumulo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (&lt;= 2^k (* (ubv_to_int x) (ubv_to_int y))))
(define-fun bvsmulo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (or (&lt; (* (sbv_to_int x) (sbv_to_int y)) 2^(k-1)) (&lt;= 2^(k-1) (* (sbv_to_int x) (sbv_to_int y)))))
(define-fun bvsdivo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (and (= (ubv_to_int x) 2^(k-1)) (= (sbv_to_int y) (- 1))))
(define-fun bvusubo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (&lt; (ubv_to_int x) (ubv_to_int y)))
(define-fun bvssubo ((x (_ BitVec k)) (y (_ BitVec k))) Bool
   (or (&lt; (sbv_to_int x) (+ (sbv_to_int y)) 2^(k-1)) (&lt;= (+ (sbv_to_int y) 2^(k-1)) (sbv_to_int x))))</code></pre>
<p>For shifts, we define a function <code>pow2</code> for shifts and its
inverse <code>log2</code>. We add a few axioms.</p>
<pre><code>⟨bitvector-axiom⟩ ::= …
 | (pow2const k) ;( +(= (pow2 k) 2^k) )    ; where k &gt;= 0 is a constant
 | (pow2add n m) ;( -(&lt;= 0 n) -(&lt;= 0 m) +(= (pow2 (+ n m)) (* (pow2 n) (pow2 m))) )
 | (log2low a)   ;( -(&lt;= 0 a) +(&lt;= (pow2 (log2 a)) a) )
 | (log2high a)  ;( -(&lt;= 0 a) +(&lt; a (* 2 (pow2 (log2 a)))) )</code></pre>
<pre><code>(define-fun bvshl ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (* (pow2 (ubv_to_int y)) (ubv_to_int x))))
(define-fun bvlshr ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (div (ubv_to_int x) (pow2 (ubv_to_int y)))))
(define-fun bvashr ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (div (sbv_to_int x) (pow2 (ubv_to_int y)))))</code></pre>
<p>For logical operations we use a <code>&amp;</code> operator over
integers that computes bitwise AND. It is left-associative, takes two
integers, and returns an integer. It returns a negative number if and
only if both arguments are negative and ensures that no bits are
truncated before performing bitwise AND.</p>
<pre><code>⟨bitvector-axiom⟩ ::= …
 | (&amp;flat (&amp; (&amp; a_ij)) (&amp; bi))
      ;( +(= (&amp; (&amp; a_11 …) … (&amp; an1 …)) (&amp; b_1 … b_m)) ) where {b_i} ∪ {-1} = { a_ij }
      ;     ( if an &quot;&amp;&quot; has only one parameter, the &amp; is omitted)
 | (&amp;shift a b k)      ;( -(&lt;= 0 k) +(= (* (&amp; (div a (pow2 k)) b) (pow2 k)) (&amp; a (* b (pow2 k)))) )
 | (&amp;split a b)        ;( +(= (+ (&amp; a b) (&amp; a (+ (* (- 1) b) (- 1)))) a) )
 | (&amp;bound a b)        ;( -(&lt;= 0 a) +(&lt;= (&amp; a b) a) )
 | (&amp;nonneg a b)       ;( -(&lt;= 0 a) +(&lt;= 0 (&amp; a b)) )</code></pre>
<p>Using this function we can define the logical operators:</p>
<pre><code>(define-fun bvnot ((x (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (- 1) (* (- 1) (ubv_to_int x)))))
(define-fun bvand ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (&amp; (ubv_to_int x) (ubv_to_int y))))
(define-fun bvor ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (ubv_to_int x) (ubv_to_int y) (* (- 1) (&amp; (ubv_to_int x) (ubv_to_int y))))))
(define-fun bvxor ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (ubv_to_int x) (ubv_to_int y) (* (- 2) (&amp;
   (ubv_to_int x) (ubv_to_int y))))))
(define-fun bvnand ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k) (bvnot (bvand x y)))
(define-fun bvnor  ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k) (bvnot (bvor x y)))
(define-fun bvxnor ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec k) (bvnot (bvxor x y)))</code></pre>
<p>Comparisons:</p>
<pre><code>(define-fun bvule ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt;= (ubv_to_int x) (ubv_to_int y)))
(define-fun bvult ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt; (ubv_to_int x) (ubv_to_int y)))
(define-fun bvuge ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt;= (ubv_to_int y) (ubv_to_int x)))
(define-fun bvugt ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt; (ubv_to_int y) (ubv_to_int x)))
(define-fun bvsle ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt;= (sbv_to_int x) (sbv_to_int y)))
(define-fun bvslt ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt; (sbv_to_int x) (sbv_to_int y)))
(define-fun bvsge ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt;= (sbv_to_int y) (sbv_to_int x)))
(define-fun bvsgt ((x (_ BitVec k)) (y (_ BitVec k))) Bool (&lt; (sbv_to_int y) (sbv_to_int x)))
(define-fun bvcomp ((x (_ BitVec k)) (y (_ BitVec k))) (_ BitVec 1)
   (ite (= x y) (_ bv1 1) (_ bv0 1)))</code></pre>
<p>Miscellaneous:</p>
<pre><code>(define-fun (_ zero_extend i) ((x (_ BitVec k))) (_ BitVec i+k)
   ((_ int_to_bv (i+k)) (ubv_to_int x)))
(define-fun (_ sign_extend i) ((x (_ BitVec k))) (_ BitVec i+k)
   ((_ int_to_bv (i+k)) (sbv_to_int x)))
(define-fun concat ((x (_ BitVec k1)) (y (_ BitVec k2))) (_ BitVec k1+k2)
   ((_ int_to_bv (k1+k2)) (+ (* (2^k2) (ubv_to_int x)) (ubv_to_int y))))
(define-fun (_ extract i j) ((x (_ BitVec k1))) (_ BitVec i-j+1)
   ((_ int_to_bv (i-j+1)) (div (ubv_to_int x) 2^j)))
(define-fun (_repeat i) ((x (_ BitVec k))) (_ BitVec i*k)
   ((_ int_to_bv (i*k)) (* ((2^(i*k)-1)/(2^k-1)) (ubv_to_int x))))
(define-fun (_ rotate_left i)  ((x (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (* 2^(i mod k) (ubv_to_int x)) (div (ubv_to_int x) 2^(-i mod k)))))
(define-fun (_ rotate_right i)  ((x (_ BitVec k))) (_ BitVec k)
   ((_ int_to_bv k) (+ (* 2^(-i mod k) (ubv_to_int x)) (div (ubv_to_int x) 2^(i mod k)))))</code></pre>
